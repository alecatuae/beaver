/* eslint-disable unicorn/prefer-module */ /* eslint-disable no-magic-numbers */ /* eslint-disable no-nested-ternary */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _nodefs = require("node:fs");
const _nodepath = require("node:path");
const _typescript = /*#__PURE__*/ _interop_require_wildcard(require("typescript"));
const _generatorhelper = require("@prisma/generator-helper");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const MIN_TS_VERSION = [
    4,
    5,
    2
];
const versionParts = _typescript.version.split(/[.-]/g).map((part)=>Number.parseInt(part, 10));
const modifiersArg = versionParts[0] >= 5 ? [] : [
    []
];
function checkTSVersion() {
    for(let i = 0; i < 3; i += 1){
        const part = versionParts[i];
        if (part < MIN_TS_VERSION[i]) {
            throw new Error(`@pothos/plugin-prisma requires typescript version >${MIN_TS_VERSION.join('.')}`);
        }
        if (part > MIN_TS_VERSION[i]) {
            return;
        }
    }
}
const defaultOutput = (0, _nodepath.resolve)(__dirname, '../generated.ts');
(0, _generatorhelper.generatorHandler)({
    onManifest: ()=>({
            prettyName: 'Pothos integration',
            requiresGenerators: [
                'prisma-client-js'
            ],
            defaultOutput
        }),
    onGenerate: async (options)=>{
        var _options_generator_output;
        checkTSVersion();
        const config = options.generator.config;
        var _config_clientOutput;
        const prismaLocation = (_config_clientOutput = config.clientOutput) !== null && _config_clientOutput !== void 0 ? _config_clientOutput : options.otherGenerators.find((gen)=>gen.provider.value === 'prisma-client-js').output.value;
        var _options_generator_output_value;
        const outputLocation = (_options_generator_output_value = (_options_generator_output = options.generator.output) === null || _options_generator_output === void 0 ? void 0 : _options_generator_output.value) !== null && _options_generator_output_value !== void 0 ? _options_generator_output_value : defaultOutput;
        const prismaTypes = buildTypes(options.dmmf, config);
        await generateOutput(options.dmmf, prismaTypes, prismaLocation, outputLocation);
        if (outputLocation === defaultOutput) {
            await generateOutput(options.dmmf, prismaTypes, prismaLocation.startsWith('@') ? prismaLocation : _nodepath.posix.join(prismaLocation, 'index.js'), (0, _nodepath.join)(outputLocation, '../esm/generated.ts'));
        }
    }
});
async function generateOutput(dmmf, prismaTypes, prismaLocation, outputLocation) {
    const importStatement = _typescript.default.factory.createImportDeclaration(...modifiersArg, [], _typescript.default.factory.createImportClause(true, undefined, _typescript.default.factory.createNamedImports([
        _typescript.default.factory.createImportSpecifier(false, undefined, _typescript.default.factory.createIdentifier('Prisma')),
        ...dmmf.datamodel.models.map((model)=>_typescript.default.factory.createImportSpecifier(false, undefined, _typescript.default.factory.createIdentifier(model.name)))
    ])), _typescript.default.factory.createStringLiteral(prismaLocation));
    const printer = _typescript.default.createPrinter({});
    const sourcefile = _typescript.default.createSourceFile(outputLocation, '', _typescript.ScriptTarget.ESNext, false, _typescript.ScriptKind.TS);
    const nodes = _typescript.default.factory.createNodeArray([
        importStatement,
        prismaTypes
    ]);
    const result = printer.printList(_typescript.ListFormat.SourceFileStatements, nodes, sourcefile);
    await new Promise((resolve, reject)=>{
        (0, _nodefs.mkdir)((0, _nodepath.dirname)(sourcefile.fileName), {
            recursive: true
        }, (err)=>{
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
    return new Promise((resolve, reject)=>{
        (0, _nodefs.writeFile)(sourcefile.fileName, `/* eslint-disable */\n${result}`, (err)=>{
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}
function buildTypes(dmmf, config) {
    function getOrderByTypeName(type) {
        var _dmmf_schema_inputObjectTypes_prisma;
        const possibleTypes = [
            `${type}OrderByWithRelationInput`,
            `${type}OrderByWithRelationAndSearchRelevanceInput`
        ];
        const orderBy = (_dmmf_schema_inputObjectTypes_prisma = dmmf.schema.inputObjectTypes.prisma) === null || _dmmf_schema_inputObjectTypes_prisma === void 0 ? void 0 : _dmmf_schema_inputObjectTypes_prisma.find((inputType)=>possibleTypes.includes(inputType.name));
        if (!orderBy) {
            return possibleTypes[0];
        }
        return orderBy.name;
    }
    const prismaUtils = config.prismaUtils === 'true';
    const modelTypes = dmmf.datamodel.models.map((model)=>{
        const relations = model.fields.filter((field)=>!!field.relationName);
        const listRelations = model.fields.filter((field)=>!!field.relationName && field.isList);
        const createInputUnavailable = !dmmf.schema.inputObjectTypes.prisma.some((input)=>input.name === `${model.name}CreateInput`);
        return _typescript.default.factory.createPropertySignature([], model.name, undefined, _typescript.default.factory.createTypeLiteralNode([
            _typescript.default.factory.createPropertySignature([], 'Name', undefined, _typescript.default.factory.createLiteralTypeNode(_typescript.default.factory.createStringLiteral(model.name))),
            _typescript.default.factory.createPropertySignature([], 'Shape', undefined, _typescript.default.factory.createTypeReferenceNode(model.name)),
            _typescript.default.factory.createPropertySignature([], 'Include', undefined, relations.length > 0 ? _typescript.default.factory.createTypeReferenceNode(`Prisma.${model.name}Include`) : _typescript.default.factory.createTypeReferenceNode('never')),
            _typescript.default.factory.createPropertySignature([], 'Select', undefined, _typescript.default.factory.createTypeReferenceNode(`Prisma.${model.name}Select`)),
            _typescript.default.factory.createPropertySignature([], 'OrderBy', undefined, _typescript.default.factory.createTypeReferenceNode(`Prisma.${getOrderByTypeName(model.name)}`)),
            _typescript.default.factory.createPropertySignature([], 'WhereUnique', undefined, _typescript.default.factory.createTypeReferenceNode(`Prisma.${model.name}WhereUniqueInput`)),
            _typescript.default.factory.createPropertySignature([], 'Where', undefined, _typescript.default.factory.createTypeReferenceNode(`Prisma.${model.name}WhereInput`)),
            ...prismaUtils ? [
                _typescript.default.factory.createPropertySignature([], 'Create', undefined, createInputUnavailable ? _typescript.default.factory.createTypeLiteralNode([]) : _typescript.default.factory.createTypeReferenceNode(`Prisma.${model.name}CreateInput`)),
                _typescript.default.factory.createPropertySignature([], 'Update', undefined, _typescript.default.factory.createTypeReferenceNode(`Prisma.${model.name}UpdateInput`))
            ] : [
                _typescript.default.factory.createPropertySignature([], 'Create', undefined, _typescript.default.factory.createTypeLiteralNode([])),
                _typescript.default.factory.createPropertySignature([], 'Update', undefined, _typescript.default.factory.createTypeLiteralNode([]))
            ],
            _typescript.default.factory.createPropertySignature([], 'RelationName', undefined, relations.length > 0 ? _typescript.default.factory.createUnionTypeNode(relations.map((field)=>_typescript.default.factory.createLiteralTypeNode(_typescript.default.factory.createStringLiteral(field.name)))) : _typescript.default.factory.createTypeReferenceNode('never')),
            _typescript.default.factory.createPropertySignature([], 'ListRelations', undefined, listRelations.length > 0 ? _typescript.default.factory.createUnionTypeNode(listRelations.map((field)=>_typescript.default.factory.createLiteralTypeNode(_typescript.default.factory.createStringLiteral(field.name)))) : _typescript.default.factory.createTypeReferenceNode('never')),
            _typescript.default.factory.createPropertySignature([], 'Relations', undefined, _typescript.default.factory.createTypeLiteralNode(relations.map((field)=>{
                const typeName = field.type;
                return _typescript.default.factory.createPropertySignature([], field.name, undefined, _typescript.default.factory.createTypeLiteralNode([
                    _typescript.default.factory.createPropertySignature([], 'Shape', undefined, field.isList ? _typescript.default.factory.createArrayTypeNode(_typescript.default.factory.createTypeReferenceNode(typeName)) : field.isRequired ? _typescript.default.factory.createTypeReferenceNode(typeName) : _typescript.default.factory.createUnionTypeNode([
                        _typescript.default.factory.createTypeReferenceNode(typeName),
                        _typescript.default.factory.createLiteralTypeNode(_typescript.default.factory.createNull())
                    ])),
                    _typescript.default.factory.createPropertySignature([], 'Name', undefined, _typescript.default.factory.createLiteralTypeNode(_typescript.default.factory.createStringLiteral(typeName))),
                    _typescript.default.factory.createPropertySignature([], 'Nullable', undefined, _typescript.default.factory.createLiteralTypeNode(field.isRequired ? _typescript.default.factory.createFalse() : _typescript.default.factory.createTrue()))
                ]));
            })))
        ]));
    });
    return _typescript.default.factory.createInterfaceDeclaration(...modifiersArg, [
        _typescript.default.factory.createModifier(_typescript.SyntaxKind.ExportKeyword),
        _typescript.default.factory.createModifier(_typescript.SyntaxKind.DefaultKeyword)
    ], 'PrismaTypes', [], [], modelTypes);
}

//# sourceMappingURL=generator.js.map