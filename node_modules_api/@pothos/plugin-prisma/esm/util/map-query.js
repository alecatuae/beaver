/* eslint-disable no-param-reassign */ /* eslint-disable no-continue */ import { getArgumentValues, getDirectiveValues, getNamedType, GraphQLIncludeDirective, GraphQLSkipDirective, isInterfaceType, isObjectType, Kind } from 'graphql';
import { PothosValidationError } from '@pothos/core';
import { setLoaderMappings } from './loader-map.js';
import { createState, mergeSelection, selectionCompatible, selectionToQuery } from './selections.js';
import { wrapWithUsageCheck } from './usage.js';
function addTypeSelectionsForField(type, context, info, state, selection, indirectPath) {
    if (selection.name.value.startsWith("__")) {
        return;
    }
    var _type_extensions;
    const { pothosPrismaInclude, pothosPrismaSelect, pothosPrismaIndirectInclude, pothosPrismaModel } = (_type_extensions = type.extensions) !== null && _type_extensions !== void 0 ? _type_extensions : {};
    if (!!(pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === void 0 ? void 0 : pothosPrismaIndirectInclude.path) && pothosPrismaIndirectInclude.path.length > 0 || !!(pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === void 0 ? void 0 : pothosPrismaIndirectInclude.paths) && pothosPrismaIndirectInclude.paths.length === 0) {
        var _pothosPrismaIndirectInclude_paths;
        resolveIndirectIncludePaths(type, info, selection, [], (_pothosPrismaIndirectInclude_paths = pothosPrismaIndirectInclude.paths) !== null && _pothosPrismaIndirectInclude_paths !== void 0 ? _pothosPrismaIndirectInclude_paths : [
            pothosPrismaIndirectInclude.path
        ], indirectPath, (resolvedType, field, path) => {
            addTypeSelectionsForField(resolvedType, context, info, state, field, path);
        });
    }
    else if (pothosPrismaIndirectInclude) {
        addTypeSelectionsForField(info.schema.getType(pothosPrismaIndirectInclude.getType()), context, info, state, selection, indirectPath);
        return;
    }
    if (!(isObjectType(type) || isInterfaceType(type))) {
        return;
    }
    if (pothosPrismaModel && !pothosPrismaSelect) {
        state.mode = "include";
    }
    if (pothosPrismaInclude !== null && pothosPrismaInclude !== void 0 ? pothosPrismaInclude : pothosPrismaSelect) {
        mergeSelection(state, {
            select: pothosPrismaSelect ? {
                ...pothosPrismaSelect
            } : undefined,
            include: pothosPrismaInclude ? {
                ...pothosPrismaInclude
            } : undefined
        });
    }
    if (selection.selectionSet) {
        addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
    }
}
function resolveIndirectIncludePaths(type, info, selection, pathPrefix, includePaths, path, resolve) {
    for (const includePath of includePaths) {
        if (pathPrefix.length > 0) {
            resolveIndirectInclude(type, info, selection, [
                ...pathPrefix,
                ...includePath
            ], path, resolve);
        }
        else {
            resolveIndirectInclude(type, info, selection, includePath, path, resolve);
        }
    }
}
function resolveIndirectInclude(type, info, selection, includePath, path, resolve, expectedType = type) {
    if (includePath.length === 0) {
        resolve(type, selection, path);
        return;
    }
    const [include, ...rest] = includePath;
    if (!selection.selectionSet || !include) {
        return;
    }
    for (const sel of selection.selectionSet.selections) {
        switch (sel.kind) {
            case Kind.FIELD:
                if (expectedType.name === type.name && !fieldSkipped(info, sel) && sel.name.value === include.name && (isObjectType(type) || isInterfaceType(type))) {
                    var _sel_alias;
                    const returnType = getNamedType(type.getFields()[sel.name.value].type);
                    var _sel_alias_value;
                    resolveIndirectInclude(returnType, info, sel, rest, [
                        ...path,
                        (_sel_alias_value = (_sel_alias = sel.alias) === null || _sel_alias === void 0 ? void 0 : _sel_alias.value) !== null && _sel_alias_value !== void 0 ? _sel_alias_value : sel.name.value
                    ], resolve);
                }
                continue;
            case Kind.FRAGMENT_SPREAD:
                resolveIndirectInclude(info.schema.getType(info.fragments[sel.name.value].typeCondition.name.value), info, info.fragments[sel.name.value], includePath, path, resolve, include.type ? info.schema.getType(include.type) : expectedType);
                continue;
            case Kind.INLINE_FRAGMENT:
                if (!sel.typeCondition || !include.type || sel.typeCondition.name.value === include.type) {
                    resolveIndirectInclude(sel.typeCondition ? info.schema.getType(sel.typeCondition.name.value) : type, info, sel, includePath, path, resolve, include.type ? info.schema.getType(include.type) : expectedType);
                }
                continue;
            default:
                throw new PothosValidationError(`Unsupported selection kind ${selection.kind}`);
        }
    }
}
function addNestedSelections(type, context, info, state, selections, indirectPath, expectedType = type) {
    let parentType = type;
    for (const selection of selections.selections) {
        switch (selection.kind) {
            case Kind.FIELD:
                if (expectedType.name !== type.name) {
                    continue;
                }
                addFieldSelection(type, context, info, state, selection, indirectPath);
                continue;
            case Kind.FRAGMENT_SPREAD:
                var _parentType_extensions;
                parentType = info.schema.getType(info.fragments[selection.name.value].typeCondition.name.value);
                addNestedSelections(parentType, context, info, state, info.fragments[selection.name.value].selectionSet, indirectPath, ((_parentType_extensions = parentType.extensions) === null || _parentType_extensions === void 0 ? void 0 : _parentType_extensions.pothosPrismaModel) === type.extensions.pothosPrismaModel ? parentType : expectedType);
                continue;
            case Kind.INLINE_FRAGMENT:
                var _parentType_extensions1;
                parentType = selection.typeCondition ? info.schema.getType(selection.typeCondition.name.value) : type;
                addNestedSelections(parentType, context, info, state, selection.selectionSet, indirectPath, ((_parentType_extensions1 = parentType.extensions) === null || _parentType_extensions1 === void 0 ? void 0 : _parentType_extensions1.pothosPrismaModel) === type.extensions.pothosPrismaModel ? parentType : expectedType);
                continue;
            default:
                throw new PothosValidationError(`Unsupported selection kind ${selection.kind}`);
        }
    }
}
function addFieldSelection(type, context, info, state, selection, indirectPath) {
    var _field_extensions;
    if (selection.name.value.startsWith("__") || fieldSkipped(info, selection)) {
        return;
    }
    const field = type.getFields()[selection.name.value];
    if (!field) {
        throw new PothosValidationError(`Unknown field ${selection.name.value} on ${type.name}`);
    }
    const fieldSelect = (_field_extensions = field.extensions) === null || _field_extensions === void 0 ? void 0 : _field_extensions.pothosPrismaSelect;
    let fieldSelectionMap;
    let mappings = {};
    if (typeof fieldSelect === "function") {
        const args = getArgumentValues(field, selection, info.variableValues);
        fieldSelectionMap = fieldSelect(args, context, (rawQuery, indirectInclude, expectedType) => {
            const returnType = getNamedType(field.type);
            const query = typeof rawQuery === "function" ? rawQuery(args, context) : rawQuery;
            const normalizedIndirectInclude = Array.isArray(indirectInclude) ? normalizeInclude(indirectInclude, getIndirectType(returnType, info), expectedType ? getNamedType(info.schema.getType(expectedType)) : undefined) : indirectInclude;
            const fieldState = createStateForType(getIndirectType(normalizedIndirectInclude ? info.schema.getType(normalizedIndirectInclude.getType()) : returnType, info), info, state);
            if (typeof query === "object" && Object.keys(query).length > 0) {
                mergeSelection(fieldState, {
                    select: {},
                    ...query
                });
            }
            if (!!(normalizedIndirectInclude === null || normalizedIndirectInclude === void 0 ? void 0 : normalizedIndirectInclude.path) && normalizedIndirectInclude.path.length > 0 || !!(normalizedIndirectInclude === null || normalizedIndirectInclude === void 0 ? void 0 : normalizedIndirectInclude.paths) && normalizedIndirectInclude.paths.length > 0) {
                var _returnType_extensions_pothosPrismaIndirectInclude, _returnType_extensions;
                var _returnType_extensions_pothosPrismaIndirectInclude_path, _normalizedIndirectInclude_paths;
                resolveIndirectIncludePaths(returnType, info, selection, (_returnType_extensions_pothosPrismaIndirectInclude_path = (_returnType_extensions = returnType.extensions) === null || _returnType_extensions === void 0 ? void 0 : (_returnType_extensions_pothosPrismaIndirectInclude = _returnType_extensions.pothosPrismaIndirectInclude) === null || _returnType_extensions_pothosPrismaIndirectInclude === void 0 ? void 0 : _returnType_extensions_pothosPrismaIndirectInclude.path) !== null && _returnType_extensions_pothosPrismaIndirectInclude_path !== void 0 ? _returnType_extensions_pothosPrismaIndirectInclude_path : [], (_normalizedIndirectInclude_paths = normalizedIndirectInclude === null || normalizedIndirectInclude === void 0 ? void 0 : normalizedIndirectInclude.paths) !== null && _normalizedIndirectInclude_paths !== void 0 ? _normalizedIndirectInclude_paths : (normalizedIndirectInclude === null || normalizedIndirectInclude === void 0 ? void 0 : normalizedIndirectInclude.path) ? [
                    normalizedIndirectInclude.path
                ] : [], [], (resolvedType, resolvedField, path) => {
                    addTypeSelectionsForField(resolvedType, context, info, fieldState, resolvedField, path);
                });
            }
            else if (normalizedIndirectInclude) {
                const targetType = info.schema.getType(normalizedIndirectInclude.getType());
                if (targetType !== returnType) {
                    addTypeSelectionsForField(targetType, context, info, fieldState, selection, []);
                }
            }
            addTypeSelectionsForField(returnType, context, info, fieldState, selection, []);
            // eslint-disable-next-line prefer-destructuring
            mappings = fieldState.mappings;
            return selectionToQuery(fieldState);
        }, (path) => {
            if (path.length === 0) {
                return selection;
            }
            const returnType = getNamedType(field.type);
            let node = null;
            resolveIndirectInclude(returnType, info, selection, path.map((name) => ({
                name
            })), [], (_, resolvedField) => {
                node = resolvedField;
            });
            return node;
        });
    }
    else {
        fieldSelectionMap = {
            select: fieldSelect
        };
    }
    if (fieldSelect && selectionCompatible(state, fieldSelectionMap, true)) {
        var _selection_alias;
        mergeSelection(state, fieldSelectionMap);
        var _selection_alias_value;
        state.mappings[(_selection_alias_value = (_selection_alias = selection.alias) === null || _selection_alias === void 0 ? void 0 : _selection_alias.value) !== null && _selection_alias_value !== void 0 ? _selection_alias_value : selection.name.value] = {
            field: selection.name.value,
            type: type.name,
            mappings,
            indirectPath
        };
    }
}
export function queryFromInfo({ context, info, typeName, select, path = [], paths = [], withUsageCheck = false }) {
    const returnType = getNamedType(info.returnType);
    const type = typeName ? info.schema.getTypeMap()[typeName] : returnType;
    let state;
    const initialSelection = select ? {
        select
    } : undefined;
    if (path.length > 0 || paths.length > 0) {
        var _returnType_extensions;
        const { pothosPrismaIndirectInclude } = (_returnType_extensions = returnType.extensions) !== null && _returnType_extensions !== void 0 ? _returnType_extensions : {};
        var _pothosPrismaIndirectInclude_path;
        resolveIndirectInclude(returnType, info, info.fieldNodes[0], (_pothosPrismaIndirectInclude_path = pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === void 0 ? void 0 : pothosPrismaIndirectInclude.path) !== null && _pothosPrismaIndirectInclude_path !== void 0 ? _pothosPrismaIndirectInclude_path : [], [], (indirectType, indirectField, subPath) => {
            resolveIndirectIncludePaths(indirectType, info, indirectField, [], paths.length > 0 ? paths.map((p) => p.map((n) => typeof n === "string" ? {
                name: n
            } : n)) : [
                path.map((n) => typeof n === "string" ? {
                    name: n
                } : n)
            ], subPath, (resolvedType, resolvedField, nested) => {
                state = createStateForType(typeName ? type : resolvedType, info, undefined, initialSelection);
                addTypeSelectionsForField(typeName ? type : resolvedType, context, info, state, resolvedField, nested);
            });
        });
    }
    else {
        state = createStateForType(type, info, undefined, initialSelection);
        addTypeSelectionsForField(type, context, info, state, info.fieldNodes[0], []);
    }
    if (!state) {
        state = createStateForType(type, info, undefined, initialSelection);
    }
    setLoaderMappings(context, info, state.mappings);
    const query = selectionToQuery(state);
    return withUsageCheck ? wrapWithUsageCheck(query) : query;
}
export function selectionStateFromInfo(context, info, typeName) {
    const type = typeName ? info.schema.getTypeMap()[typeName] : info.parentType;
    const state = createStateForType(type, info);
    if (!(isObjectType(type) || isInterfaceType(type))) {
        throw new PothosValidationError("Prisma plugin can only resolve includes for object and interface types");
    }
    addFieldSelection(type, context, info, state, info.fieldNodes[0], []);
    return state;
}
function createStateForType(type, info, parent, initialSelections) {
    var _targetType_extensions, _targetType_extensions1;
    const targetType = getIndirectType(type, info);
    const fieldMap = (_targetType_extensions = targetType.extensions) === null || _targetType_extensions === void 0 ? void 0 : _targetType_extensions.pothosPrismaFieldMap;
    const state = createState(fieldMap, ((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === void 0 ? void 0 : _targetType_extensions1.pothosPrismaSelect) ? "select" : "include", parent);
    if (initialSelections) {
        mergeSelection(state, initialSelections);
    }
    return state;
}
export function getIndirectType(type, info) {
    var _targetType_extensions;
    let targetType = type;
    while ((_targetType_extensions = targetType.extensions) === null || _targetType_extensions === void 0 ? void 0 : _targetType_extensions.pothosPrismaIndirectInclude) {
        var _targetType_extensions1;
        targetType = info.schema.getType(((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === void 0 ? void 0 : _targetType_extensions1.pothosPrismaIndirectInclude).getType());
    }
    return targetType;
}
function normalizeInclude(path, type, expectedType) {
    let currentType = path.length > 0 ? type : expectedType !== null && expectedType !== void 0 ? expectedType : type;
    const normalized = [];
    if (!(isObjectType(currentType) || isInterfaceType(currentType))) {
        throw new PothosValidationError(`Expected ${currentType} to be an Object type`);
    }
    for (const fieldName of path) {
        const field = currentType.getFields()[fieldName];
        if (!field) {
            throw new PothosValidationError(`Expected ${currentType} to have a field ${fieldName}`);
        }
        currentType = getNamedType(field.type);
        if (!(isObjectType(currentType) || isInterfaceType(currentType))) {
            throw new PothosValidationError(`Expected ${currentType} to be an Object or Interface type`);
        }
        normalized.push({
            name: fieldName,
            type: currentType.name
        });
    }
    return {
        getType: () => {
            var _expectedType_name;
            return (_expectedType_name = expectedType === null || expectedType === void 0 ? void 0 : expectedType.name) !== null && _expectedType_name !== void 0 ? _expectedType_name : normalized.length > 0 ? normalized[normalized.length - 1].type : type.name;
        },
        path: normalized
    };
}
function fieldSkipped(info, selection) {
    const skip = getDirectiveValues(GraphQLSkipDirective, selection, info.variableValues);
    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return true;
    }
    const include = getDirectiveValues(GraphQLIncludeDirective, selection, info.variableValues);
    if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return true;
    }
    return false;
}
//# sourceMappingURL=map-query.js.map
